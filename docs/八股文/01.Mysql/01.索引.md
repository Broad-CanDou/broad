---
title: 索引
date: 2022-05-17 22:29:55
permalink: /pages/1ef4bf/
categories:
  - 八股文
  - Mysql
tags:
  - 
---
 

## 1.什么是索引及为什么使用索引？

```
 索引: Mysql官方定义索引是高效获取数据的数据结构(可以理解为排好序的快速查找数据结构)。
```
**简单的理解:** 就类似书的目录(当然这样说不是很严谨，但是理解是那么回事即可)，当没有目录的时候我们想要找到一篇文章那你就要一页页的找。极大的耗费时间。当存在了目录可以很快的找到你想要的那一篇文章。所以为什么说索引是高效的获取数据的数据结构。

## 2.为什么要使用索引？

1. 如上所说 索引是高效获取数据的数据结构，那高效二字我们替换替换，那为什么要使用索引呢？**因为索引能够帮助我们快速的查询出我们想要的数据。**
2. 前面提到过 索引可以理解为排好序的数据结构。那当我们使用**分组/排序的时候那肯定减少了时间，cpu消耗的减少。**

## 3.索引的优点及缺点

### 优点
  1. 创建唯一索引，保证了数据的唯一性。
  2. 提高了数据检索效率，降低了IO成本。
  3. 使用分组/排序时，可以减少时间，降低CPU消耗。
### 缺点
  1. 创建索引和维护索引比较耗费时间，随着数据量的增加，所耗费的时间也会增加。
  **理解：** 当我们在一个表中创建索引，内部他就会排序构建索引，表中要是几百万条的话那么他的耗费的时间可想而知。
  2. 索引要占磁盘空间。对于InnoDB存储引擎 是将数据和索引存在于.ibd文件，对于MyISAM存储引擎，是将数据和索引分开存储.MYD文件存储数据。.MYI存储索引。
  3. 索引虽然很大的提高了查询速度,但是当我们增删改的时候，索引也会动态的维护，这样就会降低维护数据的速度。
   
## 4.索引的分类
```
  Mysql中索引包括唯一索引,普通索引,全文索引,单列索引,多列索引和空间索引等。
```
**细分**
* **功能逻辑**上来说: 分为唯一索引,普通索引,全文索引,主键索引。
* **物理实现方式**来说: 聚簇索引和非聚簇索引。
* **按照作用字段个数**: 单列索引和联合索引。


**1. 普通索引**<br/>
&emsp;&emsp;普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。普通索引允许在定义索引的列中插入**重复值和空值**。

**2. 唯一索引**<br/>
&emsp;&emsp;使用**UNIQUE**参数创建唯一索引,唯一索引列的值必须**唯一**，允许有空值。可以有多个索引值。

**3. 主键索引**<br/>
&emsp;&emsp;主键索引比较特殊,其实就是在唯一索引的基础上加了不为空，**NOT NULL+UNIQUE**, 一张表最多只有一个主键索引。

**4. 单列索引**<br/>
&emsp;&emsp;这个不多说了吧！创建单个字段上的索引，可以是普通索引，唯一索引等，同样可以有多个。

**5. 联合索引（多列索引）**<br/>
&emsp;&emsp;作用在多个**字段组合**的索引，使用的时候会遵循**最左匹配原则:最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配**。

**6. 全文索引**<br/>
&emsp;&emsp;全文索引主要用来查找文本中的关键字，只能在 **CHAR、VARCHAR 或 TEXT** 类型的列上创建。在 MySQL 中只有 MyISAM 存储引擎支持全文索引。全文索引允许在索引列中插入重复值和空值。不过对于大容量的数据表，生成全文索引非常消耗时间和硬盘空间。创建全文索引使用 **FULLTEXT** 关键字

## 5.适合创建索引的情况

**1. 字段的唯一性限制**<br/>
&emsp;&emsp;在业务中存在唯一特性的字段，即使是组合字段，也必须建成唯一索引(来源: Alibaba)。构建唯一索引/主键索引可以更快速的定位数据。

**2. 频繁 WHERE 查询条件的字段**<br/>
&emsp;&emsp;在查询时常常做为查询条件的热点字段，应该为此字段加上索引,大幅度的增加效率。

**3. GROUP BY和ORDER BY 的字段**<br/>
&emsp;&emsp;索引在上面讲过，他让数据按照某种**顺序**存储所以说是有序的，那在我们使用group by和order by时。
&emsp;&emsp;order by本身就是排序。那索引已经是排序好的效率上可想而知是快快的，对于group by来说进行分组，对已经排好序的分组你说快不快。

::: warning
当我们同时使用了 group by和order by时。同时字段都加了索引。大家猜猜会用到索引吗？用到哪个索引呢？对的 答案是会用到，而且用到的索引是group by的。为什么呢？因为对于sql执行流程 order by 要晚于group by(当然这是对于单列索引)。其实对于如果同时使用了order by和group by加一个**联合索引**比单列索引效率要更快。<br/>
**那面试官又问那我同时创建了单列索引和联合索引会用到哪个呢？**<br/>
大声的告诉他！你个傻der 肯定单列索引呀 **因为对于sql执行流程 order by 要晚于group by** 走到group by 那本身group by的字段存在索引，还没走到order by呢 所以就用了group by这个字段的索引喽！
面试官：年薪50w 明天来上班。
:::

**4. UPDATE、DELETE语句的WHERE字段**<br/>
&emsp;&emsp;做修改、删除的时候 where条件的字段同样可以加索引提升效率。

**5. DISTINCT字段创建索引**<br/>
&emsp;&emsp;使用去重 DISTINCT的时候给去重字段加上索引提升效率。

**6. 多表连接时 创建索引**<br/>
* WHERE 字段创建索引
* 连接字段 字段创建索引
* 连接数量尽量不要超过三张，每增加一张相当于嵌套循环一次。

::: warning
连接表的连接字段 **类型必须一致**,不一致时比如说 a.id(varchar)=c.id(int) 这样也不报错数据照样查询出来，但其实内部是做了隐式转换。那肯定要用到函数一旦用到函数 索引失效。导致效率垮垮的。
:::

**7. 区分度高的列作为索引**<br/>
&emsp;&emsp;在记录行数一定的情况下，**列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中**当然我们创建索引肯定在基数大的列上创建。<br/>
&emsp;&emsp;可以使用公式: **select count(distinct a)/count(*) from t** 计算区分度，越接近1越好。

## 5.不适合创建索引的情况

**1. 在WHERE条件中使用不到的字段不要设置**<br/>
在where（order by、group by）使用不到的字段 无需加索引。

**2. 表数据量小的情况不要设置**<br/>
在数据量小的表无需创建，对效率来说影响并不大。

**3. 有大量重复数据上的列不要建立索引**<br/>
比如说性别字段 只有男女两个值，数据的重复度太大 加了索引会反其道而行。

**4. 避免在经常更新的表中创建过多索引**<br/>
* 第一层含义: 频繁更新的字段不一定要创建索引，在更新数据时，索引也在更新。太多索引的话从而影响效率。
* 第二层含义: 避免在经常更新的表中创建过多索引。虽然提高了查询速度，但同时降低了更新表的速度。

**5. 不建议无序字段创建索引**<br/>
拿自增主键（聚簇索引）来说，底层btree叶子节点按照顺序（升序）进行排列。那列如我们使用 身份证，UUID等这些本身无序那在叶子节点会来回的做移动动态维护。导致效率低下。

**6. 不要定义冗余重复的索引**<br/>


## 6.聚簇索引和非聚簇索引区别？

### 一. 聚簇索引
::: note
1. 聚簇索引它不是一种索引类型，而是一种存储的方式。(表中所有的记录存储在叶子节点上,包括索引)
2. 对于通过主键构建的b+tree(或索引)定义为聚簇索引。
3. InnoDB有聚簇索引，MyISAM没有聚簇索引。
4. 每个MySql的表**只能有一个聚簇索引**。
5. 若是没有主键，则InnoDB按照表中非空及唯一索引的构建，若没有这样的索引。InnoDB会隐式定义一个主键来构建。
:::

#### 特征
1. 聚簇索引中将数据和索引整体在叶子节点存储(存储的是实打实的数据记录),通过主键升序排序。
2. 页内通过主键进行排序形成单向链表。
3. 各个存放的数据记录的页也是通过主键进行排序构成双向链表
#### 优点
1. 访问数据更快，对比于非聚簇索引效率会更胜一筹，因为数据都在叶子节点不用其他操作(其他操作：非聚簇索引需要回表)。
2. 对于主键的范围查找和排序查找会比较快。
#### 缺点
1. 插入的速度是依赖于插入顺序，对于自增主键的顺序插入是最快的方式，否则出现页分裂，严重影响性能。
2. 更新主键代价很高，导致更新的行移动 动态维护。因此一般定义主键不可更新。



### 二. 非聚簇索引
::: note
1. 对于不是通过主键构建的b+tree(或索引)定义为非聚簇索引。
2. 每个MySql的表**可以有多个非聚簇索引**。
:::

#### 特征
1. 非聚簇索引中将索引值和主键值在叶子节点存储,通过定义的索引值来排序。
2. 页内通过定义的索引值来进行排序形成单向链表。
3. 各个存放的数据记录的页也是通过定义的索引值进行排序构成双向链表。

#### 回表
对于非聚簇索引上述讲到叶子节点存储的是 索引值和主键值 并没有存储其他数据。那当我们查询其他数据的时候，
就会有一个回表的操作，根据索引值查找到了与其对应的主键。拿到这个主键再去聚簇索引中查询。这个就是一个回表的操作。

### 总结
对于这两个的区别:<br/>
* 从叶子点存储数据出发 聚簇索引存储的是全部数据，非聚簇索引存储的是索引值和主键。
* 从怎么构建出这两个索引出发 聚簇索引通过主键构建，而非聚簇索引通过其他列定义索引构建。
* 从存在的个数出发，聚簇索引每张表只能有一个，而非聚簇索引可以有多个。

## 7. B+树可以有多少层？
::: note
一页的大小默认是16KB。
:::
### 举个例子1
&emsp;&emsp;比如一页能存储100条数据，那当只有一层的时候那只有100条。那假如是两层 非叶子节点存储数据因不是全部数据假如说存储1000条。那么对应的整个数据就是 1000*10=100000 以此类推 第三层 1000*1000*100=100000000。这已经很多了吧，第四层就不用说了。
### 举个例子2
&emsp;&emsp;一页默认是16k 那假如一页占1k 及16k/1k=16。16k换算字节是16384,假如我们的主键是bigint(8字节) 页中的指针占6个字节 8+6=14字节。那 16384/14=1170个指针。1170*16=18720条数据，这是两层。以此类推 第三层 1170×1170×16=2190,2400条数据。

### 总结
根据上面两个例子来说，B+树可以有三层，最多最多最多是四层。