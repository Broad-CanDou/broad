---
title: 冒泡排序
date: 2022-07-22 11:21:50
permalink: /pages/de07ca/
categories:
  - 杂文笔记
  - java排序
tags:
  - 
---

## 冒泡排序

### 冒泡排序推理
> 现给定一个数组 **int num [] = {27,37,78,66,13}**
#### 推理图
<img src="../../.vuepress/public/杂文/java/冒泡排序.jpg">

#### 规律总结
* 趟数(轮数)
由上图可知我们的数组有五个元素，那一共的趟数也就是 5-1=4 一共是四趟。<br/>
那我们元素有n个，那躺数就是 n-1。
* 交换次数<br/>
第一轮：元素个数5-1=四次<br/>
第二轮：元素个数5-2=三次<br/>
第三轮：元素个数5-3=二次<br/>
第四轮: 元素个数5-4=一次

**交换次数=4+3+2+1 = 10 = (n - 1) + (n - 2) + ... + 2 + 1 = n * (n - 1) / 2**<br/>

### 代码最坏情况
~~~java
int temp=0;
for (int i=1;i<num.length;i++) {
    for (int j=i;j>0;j--){
        if(num[j-1]>num[j]){
            temp=num[j];
            num[j]=num[j-1];
            num[j-1]=temp;
        }
    }

}
~~~
**场景:** 对于大数据量进行排序的时候，尽量不要使用冒泡排序会大大降低效率。

### 代码最优情况
~~~java
int temp=0;
for (int i=1;i<num.length;i++) {
    boolean isF=false；
    for (int j=i;j>0;j--){
        if(num[j-1]>num[j]){
            temp=num[j];
            num[j]=num[j-1];
            num[j-1]=temp;
            isF=true;
        }
    }
    if(!isF){
        //那就是代表元素已经是排好的并没有进行交换
        return;
    }

}
~~~
> 以上代码中加入boolean控制，当第一次就没有元素进行交换，那就是说明元素本身就是有序的。**那对于时间复杂度就是线性阶:O(n)**

### 时间复杂度

#### 最坏情况
> 以上代码中num假如是已经是升序排好的，现将降序排列。**那对于时间复杂度就是平方阶:O(n^2)**<br/>
#### 最优情况
> 以上代码中加入boolean控制，当第一次就没有元素进行交换，那就是说明元素本身就是有序的。**那对于时间复杂度就是线性阶:O(n)**

### 稳定性
冒泡排序属于稳定的排序
