(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{313:function(s,t,_){s.exports=_.p+"assets/img/slow_query_log.60eb6823.png"},314:function(s,t,_){s.exports=_.p+"assets/img/slow_query_log1.9e76a98f.png"},315:function(s,t,_){s.exports=_.p+"assets/img/long_query_time.19aa3fe4.png"},316:function(s,t,_){s.exports=_.p+"assets/img/show_binlog.9c1e2a2d.png"},317:function(s,t,_){s.exports=_.p+"assets/img/主从复制.2402bcc8.png"},318:function(s,t,_){s.exports=_.p+"assets/img/show_master_status.7a20e6b0.png"},319:function(s,t,_){s.exports=_.p+"assets/img/show_slave_status.6bef03c0.png"},320:function(s,t,_){s.exports=_.p+"assets/img/半同步复制.9aeb6e82.png"},355:function(s,t,_){"use strict";_.r(t);var v=_(3),l=Object(v.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"sql性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sql性能优化"}},[s._v("#")]),s._v(" SQL性能优化")]),s._v(" "),t("h2",{attrs:{id:"_1-sql级别-如何优化、解决、避免sql效率问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-sql级别-如何优化、解决、避免sql效率问题"}},[s._v("#")]),s._v(" 1.sql级别[如何优化、解决、避免sql效率问题]")]),s._v(" "),t("h3",{attrs:{id:"如何定位执行慢的sql-慢查询"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何定位执行慢的sql-慢查询"}},[s._v("#")]),s._v(" 如何定位执行慢的SQL：慢查询")]),s._v(" "),t("p",[t("strong",[s._v("面试官:")]),s._v(" 你通常都是如何定位执行慢的sql的？")]),s._v(" "),t("p",[t("strong",[s._v("我:")]),s._v(" 通常要定位慢sql的话，一般我会开启"),t("strong",[s._v("慢查询日志")]),t("br")]),s._v(" "),t("ol",[t("li",[s._v("可以查看数据库慢查询日志是否开启 命令: "),t("strong",[s._v("slow variables like '%slow_query_log'")]),t("br"),s._v(" "),t("img",{attrs:{src:_(313)}}),s._v("\n命令: "),t("strong",[s._v("slow variables like '%slow_query_log%'")]),s._v(" 显示日志存储的位置。\n"),t("img",{attrs:{src:_(314)}})])]),s._v(" "),t("p",[s._v("此时是关闭的 打开命令: "),t("strong",[s._v("set slow_query_log=on")]),s._v(" "),t("br"),s._v("\n2. 同时可以查看慢查询时间阈值 命令: "),t("strong",[s._v("show variables like '%long_query_time'")]),s._v(" "),t("img",{attrs:{src:_(315)}}),s._v("\n默认十秒中，设置时间命令: "),t("strong",[s._v("set long_query_time=2")])]),s._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[s._v("打开慢查询日志并设置好时间后，使用慢查询日志分析工具: "),t("strong",[s._v("mysqldumpslow")]),s._v(" 执行的话需要退出mysql环境。/data/LAPTOP-PVKIO0GI-slow.log 是存日志的路径。\n"),t("strong",[s._v("mysqldumpslow -s t -t 5 /data/LAPTOP-PVKIO0GI-slow.log")])])]),s._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[s._v("笔记")]),s._v(" "),t("p",[s._v("-s: 是排序的意思  按照何种规则排序。\n-t: 是返回几条的意思。")])]),s._v(" "),t("br"),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),t("p",[s._v("开启慢查询日志会多少带来性能的影响，所以一般调优的时候才开启。")])]),s._v(" "),t("h3",{attrs:{id:"平常如何查看是否使用到索引呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平常如何查看是否使用到索引呢"}},[s._v("#")]),s._v(" 平常如何查看是否使用到索引呢？")]),s._v(" "),t("p",[s._v("使用 "),t("strong",[s._v("EXPLAIN/DECSRIBE")]),s._v("(两者效果一样) 这两个对sql进行分析。")]),s._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[s._v("笔记")]),s._v(" "),t("p",[s._v("使用后我们可以观察："),t("br"),s._v(" "),t("strong",[s._v("key列:")]),s._v(" 因为他是实际用到的索引值。"),t("br"),s._v(" "),t("strong",[s._v("type列:")]),s._v(" 此列表示关联类型或访问类型。也就是MySQL决定如何查找表中的行。依次从最优到最差分别为：system > const > eq_ref > ref > range > index > all。")])]),s._v(" "),t("h3",{attrs:{id:"避免索引失效-导致全盘扫描"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#避免索引失效-导致全盘扫描"}},[s._v("#")]),s._v(" 避免索引失效，导致全盘扫描")]),s._v(" "),t("ol",[t("li",[s._v("计算/函数/类型转换导致索引失效")]),s._v(" "),t("li",[s._v("范围条件右边的列索引失效(联合索引时 碰到范围查询比如 > <>,右边那列索引失效)")]),s._v(" "),t("li",[s._v("使用符号!=/<>索引失效。")]),s._v(" "),t("li",[s._v("使用 is null索引生效，is not null 索引失效。")]),s._v(" "),t("li",[s._v("like 以通配符百分号%开头索引失效  比如(like '%aa')")]),s._v(" "),t("li",[s._v("OR 前后存在非索引列，索引失效。(必须保证前后都有索引)")])]),s._v(" "),t("h2",{attrs:{id:"_2-数据库级别-数据库层面优化sql效率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据库级别-数据库层面优化sql效率"}},[s._v("#")]),s._v(" 2.数据库级别[数据库层面优化sql效率]")]),s._v(" "),t("h3",{attrs:{id:"binlog日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#binlog日志"}},[s._v("#")]),s._v(" binlog日志")]),s._v(" "),t("ol",[t("li",[t("strong",[s._v("数据库中binlog日志有什么作用及应用场景？")])])]),s._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[s._v("笔记")]),s._v(" "),t("p",[s._v("binlog日志即二进制日志文件，它记录了数据库所有执行 DDL,DML等数据库更新事件的语句。\n但不包括查询(select)show语句。")])]),s._v(" "),t("p",[t("strong",[s._v("应用场景")]),t("br")]),s._v(" "),t("ul",[t("li",[s._v("用于 "),t("strong",[s._v("数据恢复:")]),s._v(" Mysql服务器意外的停止，可以通过二进制文件来查看有哪些操作对此恢复数据。")]),s._v(" "),t("li",[s._v("用于 "),t("strong",[s._v("数据复制:")]),s._v(" 用于主从复制方面。")])]),s._v(" "),t("p",[s._v("对于Mysql数据库的数据备份,主从,主主,主备都离不开binlog，需要它同步数据。保证数据的一致。")]),s._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[s._v("如何使用binlog日志")])])]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("SHOW BINARY LOGS:")]),s._v(" 显示服务器现有的二进制日志信息。")]),s._v(" "),t("li",[t("strong",[s._v("flush logs:")]),s._v(" flush刷新log日志，自此刻开始产生一个新编号的binlog日志文件。")]),s._v(" "),t("li",[t("strong",[s._v("show master status:")]),s._v(" 即最后（最新）一个binlog日志的编号名称")]),s._v(" "),t("li",[t("strong",[s._v("reset master:")]),s._v(" 重置（清空）所有binlog日志")]),s._v(" "),t("li",[t("strong",[s._v("purge master logs to '文件名':")]),s._v(" 删除此文件之前的日志文件。")]),s._v(" "),t("li",[s._v("通过"),t("strong",[s._v("show variables like '%log_bin%':")]),s._v(" 命令查看binlog是否开启，若是没开启可以通过配置文件开启。")])]),s._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[s._v("笔记")]),s._v(" "),t("p",[s._v("找到 mysql中"),t("strong",[s._v("my.cnf")]),s._v(" 配置文件配置一下内容"),t("br"),s._v("\nlog-bin=xxx 日志文件名"),t("br"),s._v("\nbinlog_expire_logs_seconds=60000 文件的保留时间"),t("br"),s._v("\nmax_binlog_size=100M   文件上限大小,默认1GB"),t("br"),s._v("\n配置完成后 "),t("strong",[s._v("service mysqld restart")]),s._v(" 重启。")])]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("如何查看binlog日志内容？")])])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("  1. 通过 mysqlbinlog -v '日志文件路径' 命令查看。\n  2. 通过以上命令读取的内容比较多 不利于查看不容易分辨。我们可以通过命令:\n  show binlog events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];查看\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("ul",[t("li",[t("p",[t("strong",[s._v("IN 'log_name'")]),s._v(": 指定查询的binlog文件名(不指定就是第一个binlog文件)")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("FROM pos")]),s._v(": 指定从哪个pos起始点查(不指定就是从整个文件pos点开始算)")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("LIMIT [offset]")]),s._v(": 偏移量。")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("row_count")]),s._v(": 查询总条数。\n如下图所示  我们根据 show binlog 命令查出信息:\n"),t("img",{attrs:{src:_(316)}}),s._v("\n如上图所示: 知道开始的 pos和结束的pos。我们通过命令:"),t("br")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("数据恢复命令")]),s._v(" "),t("strong",[s._v("mysqlbinlog --start-position=开始的pos --stop-position=结束的pos --database=要操作的数据库 binlog的名称 | mysql -u登陆名 -p登陆密码 -v 要操作的数据库")])])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("最终执行命令(我的)")]),s._v(" "),t("strong",[s._v("mysqlbinlog --start-position=560 --stop-position=771 --database=my_test binlog.000033 | mysql -uroot -p123456 -v my_test")])])])]),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),t("p",[s._v("此命令进入到 binlog 目录下执行，而不是在mysql中。列如: cd /var/lib/mysql")])]),s._v(" "),t("h3",{attrs:{id:"主从复制层面优化性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从复制层面优化性能"}},[s._v("#")]),s._v(" 主从复制层面优化性能")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("主从复制原理\n从机(slave)读取主机(master)binlig日志来同步数据。那主要靠着以下三个线程。")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("二进制日志转储线程(Binlog dump thread):")]),s._v(" 它是一个主库线程，当从库线程连接的时候，主库可以将二进制日志发送给从库，当主库读取时间(Event) 的时候，会在binlog枷锁，读取完成之后在将锁释放掉。")]),s._v(" "),t("li",[t("strong",[s._v("从库I/O线程:")]),s._v(" 会连接到主库,向主库发动请求更新binlog。这时从库的I/O线程就可以读取到主库二进制日志转储线程发送的Binlog更新部分，并且拷贝到本地的中继日志(Relay log)。")]),s._v(" "),t("li",[t("strong",[s._v("从库 sql 线程:")]),s._v(" 会读取从库中的中继日志，并且执行日志中的事件，将从库的数据与主库保持同步。\n"),t("img",{attrs:{src:_(317)}}),s._v(" "),t("strong",[s._v("总结:")]),s._v(" 二进制日志转储线程 发送二进制日志(binlog)到从机(slave)。从机从库I/O线程接收并写入到中继日志(Relay log)。然后从库 sql 线程会对中继日志读取。以至于保持从库与主库数据保持一致。")])])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("主从复制搭建")])]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("Master主机配置")]),s._v(" "),t("ul",[t("li",[s._v("my.cnf 配置文件 配置一下属性:"),t("br"),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("属性")]),s._v(" "),t("th",[s._v("描述")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("server-id")]),s._v(" "),t("td",[s._v("主服务器唯一标识 列如: server-id=1 "),t("strong",[s._v("必选参数")])])]),s._v(" "),t("tr",[t("td",[s._v("log-bin")]),s._v(" "),t("td",[s._v("启用二进制日志，指名路径 "),t("strong",[s._v("必选参数")])])]),s._v(" "),t("tr",[t("td",[s._v("read-only")]),s._v(" "),t("td",[s._v("0表示读写(主机) 1表示只读(从机) "),t("strong",[s._v("可选参数")])])]),s._v(" "),t("tr",[t("td",[s._v("binlog_expire_logs_seconds")]),s._v(" "),t("td",[s._v("日志文件保留的时长 单位秒 "),t("strong",[s._v("可选参数")])])]),s._v(" "),t("tr",[t("td",[s._v("max_binlog_size")]),s._v(" "),t("td",[s._v("二进制日志大小 此参数最大默认值时1GB "),t("strong",[s._v("可选参数")])])]),s._v(" "),t("tr",[t("td",[s._v("binlog-ignore-db")]),s._v(" "),t("td",[s._v("不要复制的数据库"),t("strong",[s._v("可选参数")])])]),s._v(" "),t("tr",[t("td",[s._v("binlog-do-db")]),s._v(" "),t("td",[s._v("需要复制的数据库 "),t("strong",[s._v("可选参数")])])]),s._v(" "),t("tr",[t("td",[s._v("binlog_format")]),s._v(" "),t("td",[s._v("binlog格式 列如: binlig_format=STATEMENT "),t("strong",[s._v("可选参数")])])])])]),s._v("\n配置完后重启主机服务 "),t("strong",[s._v("systemctl restart mysqld")])]),s._v(" "),t("li",[t("strong",[s._v("主机建立账户并授权")]),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),t("p",[s._v("如果是Mysql8 执行以下命令语句:"),t("br"),s._v(" "),t("strong",[s._v("CREATE USER 'slave'@'%' IDENTIFIED BY '123456';")]),t("br"),s._v(" "),t("strong",[s._v("GRANT REPLICACTION SLAVE  ON  "),t("em",[s._v(".")]),s._v(" TO 'slave'@'%';")]),t("br"),s._v(" "),t("strong",[s._v("ALTER USER 'slave'@'%' IDENTIFIED WITH  mysql_native_password BY '123456';")])])]),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),t("p",[s._v("如果是Mysql5/7 执行以下命令语句:"),t("br"),s._v(" "),t("strong",[s._v("GRANT REPLICACTION SLAVE  ON  "),t("em",[s._v(".")]),s._v(" TO 'slave'@'从机数据库Ip' IDENTIFIED BY '123456';")])])]),s._v(" "),t("strong",[s._v("执行完之后刷新权限: flush privileges;")])])])])]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),t("p",[s._v("在主机刷新权限后: 执行"),t("strong",[s._v("show master status")]),s._v("记录其中position的值\n"),t("img",{attrs:{src:_(318)}})])]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("Slave从机配置")]),s._v(" "),t("ul",[t("li",[s._v("执行语句:"),t("br"),s._v(" "),t("strong",[s._v("CHANGE MASTER TO MASTER_HOST='主机IP地址' MASTER_USER='主机用户名' MASTER_PASSWORD='主机用户名的密码' MASTER_LOG_FILE='日志文件名' MASTER_LOG_POS=具体position的值(就是 show master status后的position值)")])]),s._v(" "),t("li",[s._v("执行语句 "),t("strong",[s._v("start slave;")]),s._v(" 启动slave同步")]),s._v(" "),t("li",[s._v("执行语句 "),t("strong",[s._v("show slave status\\G;")]),s._v(" 如下图红框内 出现yes则成功。\n"),t("img",{attrs:{src:_(319)}})])])])])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("如何保证数据一致性?")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("  虽然我们搭建了主从复制，但是我们要考虑如何保持数据的一致性(也就是主机和从机的数据保持一致)。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("ul",[t("li",[s._v("异步复制:"),t("br"),s._v("\n  Mysql中默认。在主库完成写入binlog日志中提交完事务后，就返回客户端。不用等待从库返回结果。那这样不会影响到主库的写入的效率，但是一旦主库宕机，从库这时还没收到binlog日志。那么造成数据丢失。")]),s._v(" "),t("li",[s._v("半同步复制: "),t("br"),s._v("\n  在异步复制时主库提交完事务后返回了客户端，而半同步复制还是转发到从库然后一系列的从库执行。当有从库执行完后会ACK\n通知主库。这样保证了数据的一致性。但是！！注意这句话 当有从库执行完后，也就是说从库不止一台。那不能就一台从库完成了然后ack通知一下 那其他的还没执行。所以在Mysql5.7版本中增加一个"),t("strong",[s._v("rpl_semi_sync_master_wait_for_slave_count")]),s._v("参数。可以对应答数量控制。\n不过显而易见 效率上也会受到影响。\n"),t("ul",[t("li",[t("strong",[s._v("半同步复制如何开启呢？")]),s._v(" "),t("ul",[t("li",[s._v("在主机,从机安装半同步的插件 在mysql中执行 "),t("strong",[s._v("install plugin rpl_semi_sync_master soname ‘semisync_master.so’;")])]),s._v(" "),t("li",[s._v("启动半同步: "),t("strong",[s._v("set global rpl_semi_sync_master_enabled=on;")])]),s._v(" "),t("li",[t("strong",[s._v("show plugins;")]),s._v(" 查看插件是否成功。如下图:\n"),t("img",{attrs:{src:_(320)}})]),s._v(" "),t("li",[t("strong",[s._v("stop slave io_thread; start slave io_thread;")]),s._v(" 重启I/o线程")])])])]),s._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[s._v("笔记")]),s._v(" "),t("p",[t("strong",[s._v("如果需要开启启动半同步状态需要将如下参数写入配置文件")]),t("br"),s._v("\nrpl_semi_sync_slave_enabled=on;"),t("br"),s._v("\nrpl_semi_sync_master_enabled=on;"),t("br"),s._v(" "),t("strong",[s._v("重要参数变量说明")]),t("br"),s._v("\nRpl_semi_sync_master_no_tx 代表没有成功接收slave提交的次数"),t("br"),s._v("\nRpl_semi_sync_master_yes_tx 代表成功接收slave事务回复的次数"),t("br"),s._v("\nrpl_semi_sync_master_timeout参数默认为10s，即主库在超过10s未收到从库的回复会自动切换为异步模式。为了保障数据的安全性，可 以将该参数值调大。"),t("br"),s._v("\n主库Rpl_semi_sync_master_status=off表示半同步复制停止，如果需要从异步复制模式恢复为半同步复制模式，只需要在从库重新开启I/O thread，命令：start slave io_thread")])])])]),s._v(" "),t("h3",{attrs:{id:"读写分离有哪些实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读写分离有哪些实现方式"}},[s._v("#")]),s._v(" 读写分离有哪些实现方式？")]),s._v(" "),t("p",[s._v("对于读写分离前提就是主从复制。在一些并发，优化层面等场景读写分离又可以将效率提升一节儿。那么读写分离如何实现呢？\n具体的实现细节就不多讲了，后续会推送到公众号可以前去搜索查看。")]),s._v(" "),t("ol",[t("li",[t("strong",[s._v("配置多个数据源:")]),s._v(" "),t("br"),s._v("\n基于spring/springboot 我们配置多个数据源，在业务逻辑层面根据情况来分开使用。\n同时我们可以使用"),t("strong",[s._v("AbstractRoutingDataSource和自定义注解")]),s._v("方式，更为方便的实现读写分离。")]),s._v(" "),t("li",[t("strong",[s._v("基于MySQL proxy代理的方式")]),t("br"),s._v("\n在应用和数据库之间增加代理层，代理层接收应用对数据库的请求，根据不同请求类型转发到不同的实例，在实现读写分离的同时可以实现负载均衡。")])]),s._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[s._v("笔记")]),s._v(" "),t("p",[s._v("MySQL的代理最常见的是mysql-proxy、cobar、mycat、Atlas等。这种方式对于应用来说，MySQL Proxy是完全透明的，应用则只需要连接到MySQL Proxy的监听端口即可。当然，这样proxy机器可能成为单点失效，但完全可以使用多个proxy机器做为冗余，在应用服务器的连接池配置中配置到多 个proxy的连接参数即可。")])]),s._v(" "),t("ul",[t("li",[s._v("mysql-proxy是一个轻量的中间代理，是官方提供的mysql中间件产品可以实现负载平衡，读写分离，failover等，依靠内部一个lua脚本实现读写语句的判断。项目地址： https://github.com/mysql/mysql-proxy ，该项目已经六七年没有维护了，官方也不建议应用于生成环境。")]),s._v(" "),t("li",[s._v("cobar是阿里提供的一个中间件，已经停止更新。项目地址：https://github.com/alibaba/cobar")]),s._v(" "),t("li",[s._v("mycat的前身就是cobar，活跃度比较高，完全使用java语言开发。 项目地址：https://github.com/MyCATApache/Mycat-Server ，该项目当前已经有8.3k的点赞量。")]),s._v(" "),t("li",[s._v("moeba（变形虫）是阿里工程师陈思儒基于java开发的一款数据库读写分离的项目(读写分离只是它的一个小功能)，与MySQL官方的MySQL Proxy相比，作者强调的是amoeba配置的方便（基于XML的配置文件，用SQLJEP语法书写规则，比基于lua脚本的MySQL Proxy简单）。更多详细介绍请参考：https://www.biaodianfu.com/amoeba.html , 下载地址：https://sourceforge.net/projects/amoeba/ 。")]),s._v(" "),t("li",[s._v("Atlas奇虎360的一个开源中间代理，是在mysql官方mysql-proxy 0.8.2的基础上进行了优化，增加一些新的功能特性。 项目地址: https://github.com/Qihoo360/Atlas ，该项目当前已经有4.4k的点赞量。")])]),s._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("strong",[s._v("基于sharding-jdbc的方式")]),t("br"),s._v("\nsharding-sphere是强大的读写分离、分表分库中间件，sharding-jdbc是sharding-sphere的核心模块。")])])])])])}),[],!1,null,null,null);t.default=l.exports}}]);